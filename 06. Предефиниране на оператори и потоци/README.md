#  Предефиниране на оператори и потоци - 27.03.2024

## Предефиниране на оператори (`operator` _overloading_):

Да разгледаме класа `Complex`, който дефинирахме като:
```cpp

class Complex {
private:
    double real;
    double imag;

public:
    // ...

    Complex add(const Complex& c) const {
        return Complex{real + c.real, imag + c.imag};
    }
};
```


Това е валидно решение, но когато работим с числа бихме искали да ги събираме с оператора `+` подобно на `int` и `float`. 

```cpp

class Complex {
private:
    double real;
    double imag;

public:
    // ...

    // Вътре в класа:
    Complex operator +(const Complex& c) const {
        return Complex{real + c.real, imag + c.imag};
    }

    // Или извън класа:
    friend Complex operator +(const double r, const Complex& c);
};

Complex operator +(const double r, const Complex& c) {
    return Complex{real + c.real, c.imag};
}
```

### Приятелски функции и класове

Приятелска функция наричаме външна функция, която има достъп до private полетата и методи на даден клас. Това се обозначава със запазената дума `friend`, последвана от типа на връщане, името и типа параметри на съответната функция.
```
class A {
public:
    friend <тип> <име>(<аргументи>);
};
```

Аналогично, приятелски клас е такъв външен клас, който има достъп до private полетата и методи на даден клас. Това се обозначава със запазената дума `friend`, последвана от запазена дума `class` и името на класа.
```
class A {
public:
    friend class <име>;
};
```

#### Пример:
```c++
class Point {
    double x, y;

public:
    Point(const double x, const double y): x(x), y(y) {}

    friend double distance(const Point&, const Point&);
};

double distance(const Point& a, const Point& b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));     // тук няма проблем да достъпим Point::x и Point::y, въпреки че са вътрешни за класа
}
```

| Спецификатор | Видимост в класа | Видимост от външния свят | Видимост от приятелски функции/класове |
| ------------ | ---------------- | ------------------------ | -------------------------------------- |
| private      | да               | не                       | да                                     |
| protected    | да               | не                       | да                                     |
| public       | да               | да                       | да                                     |


**Забележка:** В общия случай, приятелските функции противоречат на енкапсулацията, затова трябва да се използват внимателно. Вътрешните методи са за предпочитане навсякъде, където това е възможно. 

**Специални случаи:**
- Има някои непредифируеми оператори: **\*** в ролята си на префиксен оператор, **.**, **->**, **?:** (тернарен оператор), **::** и други.
- Добрата практика изисква оператор [] да присъства както за константни обекти (в ролята на getter), така и за неконстантни (връщайки референция към съответния обект).
```c++
class A {
public:
    const A& operator[](const int index) const; // ако обектът е константен, ще се извика този оператор, позволявайки да се види стойността на дадена позиция
    A& operator[](const int index);             // ако обектът не е константен, ще се извика този оператор, позволявайки да се види или промени стойността на дадена позиция
};
```
- Операторите **++** и **--** имат както постфиксна, така и префиксна версия. За да се различат един от друг, постфиксният оператор приема тип int като анонимен аргумент.
```c++
class A {
    int x;
public:
    A& operator++() {            // префиксен оператор
        this->x += 1;
        return *this;
    }

    A& operator++(int) {         // постфиксен оператор
        int tmp = this->x; 
        this->x += 1;
        return this->x;
    }
};
```

## Потоци и файлове:

**Дефиниция:** Редица от байтове, които се движат в една посока.   
**Входен поток:** поток, който е свързан с определен източник на данни.    
**Изходен поток:** поток, който е свързан с определен приемник на данни.    

### Указатели
- ifstream или istream: `get` указател, който реферира елемента, който ще се прочете при следващата входна операция. 
- ofstream или ostream: `put` указател, който реферира мястото, където ще се запише следващият елемент.

### Режими на работа
|ios|Резултат|  
|-|-|  
|ios::in|отваря файл за извличане и поставя за четене указателя в началото; по подразбиране за входни файлове|   
|ios::out|отваря файл за писане и поставя указателя за писане в началото; по подразбиране за изходни файлове|  
|ios::ate|отваря файл за писане и поставя указателя за писане в края на файла; указателят може да бъде преместен|  
|ios::app|отваря файл за писане и поставя указателя за писане в края на файла; указателят не може да бъде преместен|  
|ios::trunc|ако файлът съществува, съдържанието се изтрива|  
|ios::binary|отваря файл в двоичен режим на работа|  

### Флагове на състоянията на потока
- good
- end of file
- bad
- fail

Можем да изчистим състоянието с clear()

### Работа с указатели за писане и четене:

- seekg - премества указателя за четене с N байта спрямо позиция във файла
- seekp - премества указателя за писане с N байта спрямо позиция във файла
- tellg - връща текущата позиция на указателя за четене
- tellp - връща текущата позиция на указателя за хисане

### Позиции във файл:
       
- ios::beg - указател към началото на файла
- ios::end - указател към края на файла
- ios::curr - указател към текущата позиция във файла

### Файлове:
- Текстови
- Двоични
  - С пряк достъп
  - Може и да не е с пряк достъп

### Пример
- Отваряне на двоичен файл за **четене**  
```c++
#include <iostream>
#include <fstream>

int main()
{
    // ..
    std::ifstream file("myFile.dat", std::ios::binary);
    // ..
}
```

- Отваряне на двоичен файл за **писане**  
```c++
#include <iostream>
#include <fstream>

int main()
{
    // ..
    std::ofstream file("myFile.dat", std::ios::binary);
    // ..
}
```

- **Записване** на число в двоичен файл  
```c++
#include <iostream>
#include <fstream>

int main()
{
    std::ofstream file("myFile.dat", std::ios::binary);
    if (!file)
    {
        std::cout << "File can't be opened!" << std::endl;
        return -1;
    }

    int num = 1000;
    file.write((const char*)&num, sizeof(num));

    file.close();
}
```
- **Прочитане** на число от двоичен файл  
```c++
#include <iostream>
#include <fstream>

int main()
{
    std::ifstream file("myFile.dat", std::ios::binary);
    if (!file)
    {
        std::cout << "File can't be opened!" << std::endl;
        return -1;
    }

    int toRead;
    file.read((char*)&toRead, sizeof(num));

    file.close();
}
```

## Задачи
### 1. задача
Допълнение към класа `Set` от предишния път.   
Имплементирайте клас `Set`, който действа като множество от цели числа. Той трябва да предоставя следното: 
1. Move constructor
2. Move operator=
2. Оператори `+`, `+=` - които обединяват 2 множества (работят върху аргументи две множества)
3. Оператор `+`, който събира множество с число (работят върху аргументи: множество и цяло число) - всеки елемент на множеството се събира с числото. Трябва да работи независимо дали събираме число с множество или множество с число.
4. Оператор `*`, който умножава множество с число (работят върху аргументи: множество и цяло число) - всеки елемент на множеството се умножава с числото. Трябва да работи независимо дали умножаваме число с множество или множество с число.
5. Оператори `/`, `/=` - намират разликата на две множества.
6. Оператори `%`, `%=` - които пресмятат сечението на множества (работят върху аргументи две множества).
7. Оператори `(==, !=, <, <=, >=)` - ако едно множество е подмножество на друго, тогава то е по-малко
8. Оператор `[]` - който по зададенo число връща дали то се намира в множеството

Напишете и програма (main и други функции) с която да покажете използването на операторите.

### 2. задача
Да се дефинира клас `String`, който имитира `string` от стандартната библиотека. Нека се дефинират следните функции:

- Конструктор с параметър `const char *` с подразбираща стойност празен низ
- Конструктор за копиране
- Оператор `=` с параметър `const char *`
- Оператор `=` с параметър `String`
- Деструктор
- Move семантики
- Оператор `[]` за достъп до символ по индекс
- Оператор `+` в 3 варианта - `const char * + String` , `String + String` , `String + const char *`
- Оператор `+=` в 2 варианта - `String += String` , `String += const char *`
- Оператори за сравнение `==` , `!=` , `<=` , `<` , `>` , `>=` в 3 варианта - `const char * и String` , `String и String` , `String и const char *`
- Оператори `<<` и `>>` за изход и вход от поток, като за вход може да допуснем, че няма да се въвежда низ с дължина по-голяма от 256 символа
- Член-функция `length` показваща размера на низа
- Член-функция `empty` показваща дали низа е празен
- Член-функция `c_str` връщаща низа като `const char *`

### 3. задача
Нека имаме бинарен файл, който съдържа списък от записи с оценки на различни студенти по различни предмети. Всеки запис се състои от следните 3 полета:
- `studentId`: Факултетен номер на студента. Масив от 10 символа.
- `courseId`: Идентификационен номер на курса. Масив от 6 символа.
- `note`: Оценка на дадения студент по дадения предмет. Положително число, 4 байта.    
       
Да се имплементират следните функции:
- `getStudentNotes(studentId)`, която изписва в конзолата всички оценки на даден студент.
- `getCourseNotes(courseId)`, която изписва в конзолата всички оценки по даден предмет.
- `getStudentAverage(studentId)`, която връща средния успех на даден студент.
- `getCourseAverage(courseId)`, която връща средния успех по даден предмет.
