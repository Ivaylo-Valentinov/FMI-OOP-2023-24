# Конструктори - 06.03.2024

### Интерфейс и Имплементация:

_**Интерфейсът**_ на един клас или метод отговаря на въпросите **_"Какво прави този клас/метод и как се ползва?"_**

_**Имплементацията**_ отговаря на въпроса: **_"Как го прави?"_**

_**Примери**_:

Събиране на целочислени (`int`) стойности в C++:
  - _Интерфейс_: За да съберем две стойности `x` и `y`, пишем `x + y`. Резултатът от операцията е сборa на `x` и `y` (модуло $2^{32}$ за 32-битов `int`).
  - _Имплементация_: C++ кодът се компилира до асемблер, който се транслира до машинни инструкции, който се изпълняват от процесора. Процесорът е изграден от милиарди на брои транзистори и жици. Механизмът на работа на един транзистор се обяснява от законите на квантовата механика...

Както може да се досетите от примерите основната _цел_ на разделянето на _интерфейс_ и _имплементация_ е, че това ни позволява да боравим с дадени обекти - напр. да пишем код или да караме кола - _**без**_ да има нужда да знаем всеки имплементационен детайл, стига да сме наясно с техните интерфейси (т.е. да знаем кое какво прави).


### За момента е важно да знаете следните неща:
  - Конструкторите са _специални_ методи на даден клас/тип, които се извикват _автоматично_, когато създаваме нови обекти/инстанции от този клас.
  - Конструкторте винаги се казват по същия начин като класа.
  - Както може да дефинирате повече от една функция с едно и също име (_function overloading_), така може да дефинирате и много на брой конструктори, всеки от които приема различни по брой или вид аргументи.
  - Ако дефинираме _какъвто и да е конструктор_ компилаторът няма да създаде конструктор без параметри  _по подразбиране_.


## Задачи
## 1. задача
Имате клас `Form`, който притежава следните конструктори:
```cpp
Form::Form(const double num1, const double num2) {
  cout << "Form::Form(1,2)" << endl;
}

Form::Form() {
  cout << "Form::Form()" << endl;
}

Form::Form(const Form& that) {
  cout << "Form::Form(const Form& that)" << endl;
}
```
Какъв ще е резултатът от следните фрагменти код?

```cpp
Form c1{2, 1};
Form c2{c1};
```

```cpp
Form c1{2, 1};
Form c2 = c1;
```

```cpp
Form c1{2, 1}, c2;
c2 = c1;
```


## 2. задача
Представете си, че сте част от екип, който разработва програма за електронна книжарница. Вашата задача е да имплементирате клас Book, в който да пазим описанието на всяка различните книги (заглавия), с които разполага книжарницата. От какви полета (член-данни) се нуждае класа Book? Какви методи (член-функции) смятате да добавите в Book?     
Какви други класове мислите, че са нужни за една такава система?

## 3. задача
Рационални числа: Дефинирайте клас `Rational`, който енкапсулира концепцията за рационално число, като за целта имплементирате следните _**методи**_:
  - конструктор, който приема две цели числа - съответно за числител и знаменател.
  - `add`, който събира настоящото число (`this`) с друго рационално.
  - `sub`, който вади от настоящото число друго рационално.
  - `multiply`, който умножава настоящото число по друго рационално.
  - `divide`, който дели настоящото число на друго рационално.
  - `print`, който отпечатва числото на `std::cout`.
  - "празен" default (т.е. без аргументи) конструктор.


## 4. задача
Комплексни числа: Дефинирайте клас `Complex`, който енкапсулира концепцията за комплексно число, като за целта имплементирате следните _**методи**_:
  - конструктор, който приема две цели числа, съответстващи на реалната и имагинерната части на числото.
  - `add`, който събира настоящото число (`this`) с друго комплексно число.
  - `sub`, който вади от настоящото число друго комплексно число.
  - `multiply`, който умножава настоящото число по друго комплексно число.
  - `divide`, който дели настоящото число на друго комплексно число.
  - `nеgate`, коята връща противоположното на даденото число.
  - `conjugate`, която връща комплексното спрегнато на даденото число


### Източници
За още интересни задачи и полезна информация може да видите репото на [Генчо Жилков](https://github.com/Gencho-Zhilkov/fmi-oop-group-7-2023) от миналата година.