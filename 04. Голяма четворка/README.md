# Голяма четворка - 13.03.2024


За примерите ще ползваме класа `Complex`:
```cpp
class Complex {
private:
    double real;
    double imag;

public:
    ...
};
```
### **Ако използваме динамична памет за член-данните трябва да реализираме цялата голяма четворка!**

### Конструктори

**NB!** Ако не дефинираме експлицитно конструктор(и) за класа `Complex::Complex`, компилаторът ще създаде автоматично конструктор без параметри.  

```cpp
Complex::Complex(const double real=0, const double imag=0) {
    this->real = real;
    this->imag = imag;
}
```

```cpp
Complex::Complex(const double real=0, const double imag=0):
    real(real), imag(imag) {}
```

```cpp
Complex::Complex(): real(0), imag(0) {}

Complex::Complex(const double real, const double imag):
    real(real), imag(imag) {}
```


### Създаване на _"копие"_ на вече съществуващ обект (_Copy_ конструктор):

- **&** e нужен за копи конструктора иначе не би бил копи конструктор.
- Ако не дефинираме експлицитно копи конструктор за класа `Complex::Complex`, компилаторът ще създаде автоматично такъв.  

```cpp
Complex::Complex(const Complex& that) {
    this->real = that.real;
    this->imag = that.imag;
}
```

```cpp
Complex::Complex(const Complex& that) {
    real = that.real;
    imag = that.imag;
}
```

```cpp
Complex::Complex(const Complex &that):
    real(that.real), imag(that.imag) {}
```


###  Оператор за присвояване: присвояване на _**вече съществуващ**_ обект от даден клас!

-  `if (this != &that)` проверяваме дали се опитваме да присвоим един обект на себе си
- Ако не дефинираме експлицитно оператор за присвояване за класа `Complex::Complex`, компилаторът ще създаде автоматично такъв, който просто копира стойностите на член-данните.  

```cpp
Complex& Complex::operator =(const Complex& that) {
    if (this != &that) {
        real = that.real;
        imag = that.imag;
    }
    return *this;
}
```

###  Унищожаване на обект (деструктор)

- Деструктор наричаме специален метод без тип на връщане и параметри, чието име съвпада с името на класа, предшествано от тилда (~). Неговата роля е да изтрие заделената динамична памет. Извикването му става автоматично при унищожаване на обекта в края на областта, в която е дефиниран.
- **NB!** Ако използваме динамична памет за член-данните трябва да си дефинираме експлицитен конструктор!

```cpp
Complex::~Complex() {
    // Какво трябва да се добави тук?
}
```


## Задачи
## 1. задача
Имплементирайте клас `Set`, който действа като множество от цели числа. Той трябва да предоставя следните член-функции: 
1. `bool addElement(const int element)` - ако елементът не присъства в множеството, го добавя и връща истина, в противен случай не прави нищо и връща лъжа
2. `bool deleteElement(const int element)` - ако елементът присъства в множеството, го изтрива и връща истина, в противен случай не прави нищо и връща лъжа
3. `void print()` - принтира всички елементи от множеството
4. `void setUnion(const Set other)` - извършва обединение текущото множества и other като запазва резултатът в текущото множество
5. `voit setIntersection(const Set other)` - ианалогично на горната функция звършва сечение на множества


### Източници
За още интересни задачи и полезна информация може да видите репото на [Генчо Жилков](https://github.com/Gencho-Zhilkov/fmi-oop-group-7-2023) от миналата година.